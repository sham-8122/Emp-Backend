This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  config/
    db.js
    redis.js
  controllers/
    auth.controller.js
    employee.controller.js
  middlewares/
    admin.middleware.js
    auth.middleware.js
    logger.middleware.js
  models/
    employee.model.js
    index.js
    user.model.js
  routes/
    auth.routes.js
    employee.routes.js
  validations/
    employee.validation.js
  app.js
package.json
server.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/config/db.js">
const { Sequelize } = require('sequelize');
require('dotenv').config();

const sequelize = new Sequelize(
  process.env.DB_NAME,
  process.env.DB_USER,
  process.env.DB_PASSWORD,
  {
    host: process.env.DB_HOST,
    dialect: 'postgres',
    logging: false
  }
);

module.exports = sequelize;
</file>

<file path="src/config/redis.js">

</file>

<file path="src/controllers/auth.controller.js">
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { User } = require('../models');

exports.register = async (req, res) => {
  try {
    const { name, email, password } = req.body;

    const hashedPassword = await bcrypt.hash(password, 10);

    const user = await User.create({
      name,
      email,
      password: hashedPassword
    });

    res.status(201).json({ message: "User registered successfully" });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({ where: { email } });
    if (!user) return res.status(404).json({ message: "User not found" });

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) return res.status(400).json({ message: "Invalid password" });

    const token = jwt.sign(
      { id: user.id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: "1d" }
    );

    res.json({ token });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};
</file>

<file path="src/controllers/employee.controller.js">
const { Employee } = require("../models");
const { fn, col, Op } = require("sequelize"); // Import Op for search operators

/* ==============================
   GET EMPLOYEES (SEARCH + PAGINATION)
============================== */
exports.getEmployees = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 5;
    const search = req.query.search || ""; // Get search term
    const offset = (page - 1) * limit;

    // Dynamic Search Condition
    const searchCondition = search
      ? {
          [Op.or]: [
            { name: { [Op.iLike]: `%${search}%` } }, // Case-insensitive (Postgres)
            { email: { [Op.iLike]: `%${search}%` } },
            { role: { [Op.iLike]: `%${search}%` } },
          ],
        }
      : {};

    const { count, rows } = await Employee.findAndCountAll({
      where: searchCondition,
      order: [["createdAt", "DESC"]],
      limit: limit,
      offset: offset,
    });

    res.json({
      totalItems: count,
      totalPages: Math.ceil(count / limit),
      currentPage: page,
      employees: rows,
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

/* ==============================
   CREATE EMPLOYEE
============================== */
exports.createEmployee = async (req, res) => {
  try {
    const employee = await Employee.create(req.body);
    res.status(201).json(employee);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

/* ==============================
   UPDATE EMPLOYEE
============================== */
exports.updateEmployee = async (req, res) => {
  try {
    const { id } = req.params;
    await Employee.update(req.body, { where: { id } });
    const updatedEmployee = await Employee.findByPk(id);
    res.json(updatedEmployee);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

/* ==============================
   DELETE EMPLOYEE
============================== */
exports.deleteEmployee = async (req, res) => {
  try {
    const { id } = req.params;
    const employee = await Employee.findByPk(id);
    if (!employee) return res.status(404).json({ message: "Not found" });
    await employee.destroy();
    res.json({ message: "Deleted successfully" });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

/* ==============================
   STATS
============================== */
exports.getEmployeeStats = async (req, res) => {
  try {
    const totalEmployees = await Employee.count();
    const totalSalary = await Employee.sum("salary");
    const avgSalary = await Employee.findOne({
      attributes: [[fn("AVG", col("salary")), "avgSalary"]],
      raw: true,
    });
    const highestPaid = await Employee.findOne({ order: [["salary", "DESC"]] });

    res.json({
      totalEmployees,
      totalSalary: totalSalary || 0,
      averageSalary: Number(avgSalary?.avgSalary || 0).toFixed(2),
      highestPaidEmployee: highestPaid ? highestPaid.name : null,
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};
</file>

<file path="src/middlewares/admin.middleware.js">
exports.isAdmin = (req, res, next) => {
  // Check if the user role from the decoded token is 'admin'
  if (req.user && req.user.role === 'admin') {
    next();
  } else {
    return res.status(403).json({ message: "Access Denied: Admins only." });
  }
};
</file>

<file path="src/middlewares/auth.middleware.js">
const jwt = require('jsonwebtoken');

exports.verifyToken = (req, res, next) => {
  const token = req.headers.authorization?.split(" ")[1];

  if (!token) return res.status(403).json({ message: "No token provided" });

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (err) {
    return res.status(401).json({ message: "Invalid Token" });
  }
};
</file>

<file path="src/middlewares/logger.middleware.js">

</file>

<file path="src/models/employee.model.js">
module.exports = (sequelize, DataTypes) => {
  return sequelize.define('Employee', {
    name: {
      type: DataTypes.STRING,
      allowNull: false
    },
    email: {
      type: DataTypes.STRING,
      allowNull: false
    },
    role: {
      type: DataTypes.STRING,
      allowNull: false
    },
    salary: {
      type: DataTypes.FLOAT,
      allowNull: false
    }
  });
};
</file>

<file path="src/models/index.js">
const Sequelize = require('sequelize');
const sequelize = require('../config/db');

const db = {};

db.Sequelize = Sequelize;
db.sequelize = sequelize;

db.User = require('./user.model')(sequelize, Sequelize);
db.Employee = require('./employee.model')(sequelize, Sequelize);

module.exports = db;
</file>

<file path="src/models/user.model.js">
module.exports = (sequelize, DataTypes) => {
  return sequelize.define('User', {
    name: {
      type: DataTypes.STRING,
      allowNull: false
    },
    email: {
      type: DataTypes.STRING,
      unique: true
    },
    password: {
      type: DataTypes.STRING,
      allowNull: false
    },
    role: {
      type: DataTypes.STRING,
      defaultValue: "admin"
    }
  });
};
</file>

<file path="src/routes/auth.routes.js">
const router = require('express').Router();
const { register, login } = require('../controllers/auth.controller');

router.post('/register', register);
router.post('/login', login);

module.exports = router;
</file>

<file path="src/routes/employee.routes.js">
const router = require("express").Router();
const employeeController = require("../controllers/employee.controller");
const { verifyToken } = require("../middlewares/auth.middleware");
const { isAdmin } = require("../middlewares/admin.middleware"); // Import

router.get("/stats", verifyToken, employeeController.getEmployeeStats);
router.get("/", verifyToken, employeeController.getEmployees);
router.post("/", verifyToken, employeeController.createEmployee);
router.put("/:id", verifyToken, employeeController.updateEmployee);

// Protect DELETE route with isAdmin
router.delete("/:id", verifyToken, isAdmin, employeeController.deleteEmployee);

module.exports = router;
</file>

<file path="src/validations/employee.validation.js">

</file>

<file path="src/app.js">
const express = require('express');
const cors = require('cors');
const morgan = require('morgan');

const authRoutes = require('./routes/auth.routes');
const employeeRoutes = require('./routes/employee.routes');

const app = express();

app.use(cors());
app.use(express.json());
app.use(morgan('dev'));

app.use('/api/auth', authRoutes);
app.use('/api/employees', employeeRoutes);

module.exports = app;
</file>

<file path="package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.6",
    "dotenv": "^17.2.4",
    "express": "^5.2.1",
    "jsonwebtoken": "^9.0.3",
    "morgan": "^1.10.1",
    "pg": "^8.18.0",
    "pg-hstore": "^2.3.4",
    "redis": "^5.10.0",
    "sequelize": "^6.37.7",
    "yup": "^1.7.1"
  }
}
</file>

<file path="server.js">
require('dotenv').config();
const app = require('./src/app');
const { sequelize } = require('./src/models');

const PORT = process.env.PORT || 5000;

sequelize.sync().then(() => {
  console.log("Database Connected");
  app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
  });
});
</file>

</files>
